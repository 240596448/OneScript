
using System;
using ScriptEngine.Machine;
using ScriptEngine.Machine.Contexts;



/// <summary>
/// 
/// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
/// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
/// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
/// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
/// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
/// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.
/// </summary>
[ContextClass("БуферДвоичныхДанных", "BinaryDataBuffer")]
class BinaryDataBuffer : AutoContext<BinaryDataBuffer>
{

    private IValue _ByteOrder;

    private int _Size;

    private bool _ReadOnly;

    public BinaryDataBuffer()
    {
    }


    /// <summary>
    /// 
    /// 
    /// </summary>
    ///
    /// <param name="Size">
    /// Размер буфера в байтах. </param>
    /// <param name="Byte order">
    /// Порядок байтов.
    /// Значение по умолчанию: LittleEndian. </param>

    ///

    [ScriptConstructor]
    public static BinaryDataBuffer Constructor(int Size, IValue Byte_order = null)
    {
        return new BinaryDataBuffer();
    }

    /// <summary>
    /// 
    /// Текущий порядок байтов. Влияет на операции чтения и записи целых чисел в буфер.
    /// </summary>
    /// <value>ПорядокБайтов (ByteOrder)</value>
    [ContextProperty("ПорядокБайтов", "ByteOrder")]
    public IValue ByteOrder
    {
        get { return _ByteOrder; }
        set { _ByteOrder = value; }
    }


    /// <summary>
    /// 
    /// Размер буфера в байтах.
    /// </summary>
    /// <value>Число (Number)</value>
    [ContextProperty("Размер", "Size")]
    public int Size
    {
        get { return _Size; }

    }


    /// <summary>
    /// 
    /// Значение Истина указывает, что данный буфер предназначен только для чтения.
    /// </summary>
    /// <value>Булево (Boolean)</value>
    [ContextProperty("ТолькоЧтение", "ReadOnly")]
    public bool ReadOnly
    {
        get { return _ReadOnly; }

    }


    /// <summary>
    /// 
    /// Заменить значения, начиная с заданной позиции, значениями из заданного буфера.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, начиная с которой требуется записать содержимое буфера. </param>
    /// <param name="Bytes">
    /// Байты, которыми нужно заполнить часть буфера. </param>
    /// <param name="Number">
    /// Количество байт, которые требуется заменить. </param>

    ///

    ///
    [ContextMethod("Записать", "Write")]
    public void Write(int Position, IValue Bytes, int Number = null)
    {

    }


    /// <summary>
    /// 
    /// Записать целое 16-битное положительное число в заданную позицию.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется записать число. </param>
    /// <param name="Value">
    /// Число, которое требуется записать.
    /// Если значение не помещается в 16 бит, будет вызвано исключение. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, который будет использован для кодировки числа при записи в буфер. Если не установлен, то будет использован порядок байтов, заданный для текущего экземпляра БуферДвоичныхДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///

    ///
    [ContextMethod("ЗаписатьЦелое16", "WriteInt16")]
    public void WriteInt16(int Position, int Value, IValue ByteOrder = null)
    {

    }


    /// <summary>
    /// 
    /// Записать целое 32-битное положительное число в заданную позицию.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется записать число. </param>
    /// <param name="Value">
    /// Число, которое требуется записать.
    /// Если значение не помещается в 32 бита, будет вызван исключение. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, который будет использован для кодировки числа при записи в буфер. Если не установлен, то будет использован порядок байтов, заданный для текущего экземпляра БуферДвоичныхДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///

    ///
    [ContextMethod("ЗаписатьЦелое32", "WriteInt32")]
    public void WriteInt32(int Position, int Value, IValue ByteOrder = null)
    {

    }


    /// <summary>
    /// 
    /// Записать целое 64-битное положительное число в заданную позицию.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется записать число. </param>
    /// <param name="Value">
    /// Число, которое требуется записать.
    /// Если значение не помещается в 64 бита, будет вызвано исключение. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, который будет использован для кодировки числа при записи в буфер. Если не установлен, то используется порядок байтов, заданный для текущего экземпляра БуферДвоичныхДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///

    ///
    [ContextMethod("ЗаписатьЦелое64", "WriteInt64")]
    public void WriteInt64(int Position, int Value, IValue ByteOrder = null)
    {

    }


    /// <summary>
    /// 
    /// Создает новый буфер, содержащий элементы текущего буфера в противоположном порядке.
    /// </summary>
    ///

    ///
    /// <returns name="BinaryDataBuffer">
    /// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
    /// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
    /// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
    /// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
    /// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
    /// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.</returns>

    ///
    [ContextMethod("Перевернуть", "Reverse")]
    public IValue Reverse()
    {
        return null;
    }


    /// <summary>
    /// 
    /// Получает значение элемента на указанной позиции.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция элемента в буфере. Нумерация начинается с 0. </param>

    ///
    /// <returns name="Number">
    /// Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.</returns>

    ///
    [ContextMethod("Получить", "Get")]
    public int Get(int Position)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Создает новый буфер, использующий заданное количество байтов из исходного буфера, начиная с заданной позиции (нумерация с 0). Если количество не задано, то новый буфер является представлением элементов текущего буфера, начиная с заданного индекса и до конца.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, начиная с которой будет создан новый буфер. </param>
    /// <param name="Number">
    /// Количество байтов, которые требуется отобразить в срезе. Если на задано, то отображаются все байты от начала среза до конца исходного буфера.
    /// Значение по умолчанию: Неопределено. </param>

    ///
    /// <returns name="BinaryDataBuffer">
    /// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
    /// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
    /// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
    /// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
    /// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
    /// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.</returns>

    ///
    [ContextMethod("ПолучитьСрез", "GetSlice")]
    public IValue GetSlice(int Position, int Number = null)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Выполняет чтение байтов из буфера и помещает их в новый буфер.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, начиная с которой требуется прочитать байты. </param>
    /// <param name="Number">
    /// Количество байтов, которое требуется прочитать. </param>

    ///
    /// <returns name="BinaryDataBuffer">
    /// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
    /// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
    /// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
    /// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
    /// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
    /// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.</returns>

    ///
    [ContextMethod("Прочитать", "Read")]
    public IValue Read(int Position, int Number)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Выполняет чтение целого 16-битного положительного числа на заданной позиции.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется прочитать число. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, используемый при чтении числа.
    /// Если не задан, используется порядок, определенный для текущего экземпляра ЧтениеДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///
    /// <returns name="Number">
    /// Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.</returns>

    ///
    [ContextMethod("ПрочитатьЦелое16", "ReadInt16")]
    public int ReadInt16(int Position, IValue ByteOrder = null)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Прочитать целое 32-битное положительное число на заданной позиции.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется прочитать число. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, используемый при чтении числа.
    /// Если не задан, используется порядок, определенный для текущего экземпляра ЧтениеДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///
    /// <returns name="Number">
    /// Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.</returns>

    ///
    [ContextMethod("ПрочитатьЦелое32", "ReadInt32")]
    public int ReadInt32(int Position, IValue ByteOrder = null)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Выполняет чтение целого 64-битного положительного числа на заданной позиции.
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которой требуется прочитать число. </param>
    /// <param name="ByteOrder">
    /// Порядок байтов, используемый при чтении числа.
    /// Если не задан, используется порядок, определенный для текущего экземпляра ЧтениеДанных.
    /// Значение по умолчанию: Неопределено. </param>

    ///
    /// <returns name="Number">
    /// Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.</returns>

    ///
    [ContextMethod("ПрочитатьЦелое64", "ReadInt64")]
    public int ReadInt64(int Position = null, IValue ByteOrder = null)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Разделить буфер на части по заданному разделителю.
    /// </summary>
    ///

    /// <remarks>
    /// 
    /// По двоичному буферу
    /// </remarks>
    ///
    /// <param name="Separator">
    /// Разделитель. </param>

    ///
    /// <returns name="Array">
    /// Предназначен для доступа к элементам массива, его методам и конструктору.</returns>

    ///
    [ContextMethod("Разделить", "Split")]
    public IValue Split(IValue Separator)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Разделить буфер на части по заданному разделителю.
    /// </summary>
    ///

    /// <remarks>
    /// 
    /// По массиву разделителей
    /// </remarks>
    ///
    /// <param name="Separators">
    /// Массив разделителей. Может содержать значения типа БуферДвоичныхДанных. </param>

    ///
    /// <returns name="Array">
    /// Предназначен для доступа к элементам массива, его методам и конструктору.</returns>

    ///
    [ContextMethod("Разделить", "Split")]
    public IValue Split(IValue Separators)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Создает копию массива.
    /// </summary>
    ///

    ///
    /// <returns name="BinaryDataBuffer">
    /// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
    /// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
    /// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
    /// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
    /// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
    /// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.</returns>

    ///
    [ContextMethod("Скопировать", "Copy")]
    public IValue Copy()
    {
        return null;
    }


    /// <summary>
    /// 
    /// Создает новый буфер, содержащий элементы текущего буфера и, за ними, элементы заданного буфера.
    /// </summary>
    ///
    /// <param name="Buffer">
    /// Буфер, который будет соединен с исходным. </param>

    ///
    /// <returns name="BinaryDataBuffer">
    /// Коллекция байтов фиксированного размера с возможностью произвольного доступа и изменения по месту.
    /// Размер буфера формально не ограничен, но поскольку все данные буфера полностью находятся в оперативной памяти, при попытке создать буфер слишком большого размера доступной памяти может оказаться недостаточно, в результате чего будет вызвано исключение. Поэтому при работе с буферами двоичных данных необходимо соотносить их размер с доступным объемом оперативной памяти.
    /// При создании буфера можно указать порядок байтов, который будет использован для операций с целыми числами. При этом если буфер не создан явно, а получен с помощью вызова метода другого объекта, то порядок байтов в полученном буфере будет унаследован от порядка байтов, заданного для того объекта, метод которого вызывается.
    /// Например, если буфер получен с помощью вызова метода ПрочитатьВБуферДвоичныхДанных, то порядок байтов в полученном буфере будет равен значению свойства ПорядокБайтов.
    /// Возможен также более сложный случай наследования порядка байтов. Если буфер получен с помощью вызова метода ПолучитьБуферДвоичныхДанных, то порядок байтов у полученного буфера будет выбираться из объекта ЧтениеДанных, из которого был получен объект РезультатЧтенияДанных. 
    /// Порядок байтов, заданный для объекта ЧтениеДанных, будет использован во всех объектах, полученных на его основании.</returns>

    ///
    [ContextMethod("Соединить", "Concat")]
    public IValue Concat(IValue Buffer)
    {
        return null;
    }


    /// <summary>
    /// 
    /// Устанавливает значение элемента на заданной позиции (нумерация начинается с 0).
    /// </summary>
    ///
    /// <param name="Position">
    /// Позиция, на которую требуется поместить новое значение. </param>
    /// <param name="Value">
    /// Значение, которое требуется установить в заданную позицию буфера.
    /// Если значение больше 255 или меньше 0, будет выдана ошибка о неверном значении параметра. </param>

    ///

    ///
    [ContextMethod("Установить", "Set")]
    public void Set(int Position, int Value)
    {

    }


    /// <summary>
    /// 
    /// Переводит текущий буфер в режим "только для чтения". 
    /// Попытка изменить состояние буфера приведет к вызову исключения.
    /// </summary>
    ///

    ///

    ///
    [ContextMethod("УстановитьТолькоЧтение", "SetReadOnly")]
    public void SetReadOnly()
    {

    }

}